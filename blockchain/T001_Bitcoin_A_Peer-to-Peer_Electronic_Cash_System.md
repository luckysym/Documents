# Bitcoin: A Peer-to-Peer Electronic Cash System

Satoshi Nakamoto

## 摘要
&emsp;&emsp;一种无需经过金融机构，允许直接端到端在线支付的，纯粹点对点版本的电子现金。尽管电子签名技术可以提供部分解决方案，但仍然需要一个可信任的第三方以防止重复支付的问题（double-spending），这样就缺少了（作为电子货币的）主要好处。于是我们提出一项用于解决重复支付问题的解决方案，一种点对点网络（Peer-to-peer network）。该网络计算每笔交易相关信息（包括交易时间等）的Hash值，并将该交易的Hash数据串联到一个不断延伸的、使用Hash值表示的工作证明（Proof-of-work）数据链中，从而将一笔交易形成一个不可变更的数据记录，除非重新计算（数据链中）所有的工作证明（Proof-of-work）。最长的数据链不仅仅作为其中所有交易事件的证明，也证明了它来自最强大的CPU计算能力（即：其中这些交易是被最强大的计算能力所确认的）。只要占多数CPU计算能力的节点没有联合起来攻击这个网络，那么它们将生成一个最长的数据链，从而赶超攻击者（生成的数据链）。这个网络本身结构简单，消息尽最大可能在网络中以广播的形式传播，各个节点也可以自由地离线和上线，对于节点下线后的所有交易事件，节点只需要接受最长的工作证明数据链即可。

> 译者理解：
> 1. 每笔交易的数据包括时间，连同区块链中的某些数据，共同计算出一个hash码，这个hash码与交易信息组成一个记录追加到区块链中，形成一个一环套一环的验证，如果篡改，就需要从头计算整个区块链。
> 2. 重复支付的问题是计算能力投票决定的。区块链越长，说明由计算能力确认的交易越多，可信度越高，如果两条区块链存在重复支付的交易，那么以链长最长的为准，这是一个类似于投票机制的约定，并不表示链长越长的交易一定正确。
> 3. 理论上控制了51%的计算能力，就可以控制整个比特币网络。

## 1. 介绍
&emsp;&emsp;Internet上的电子商务，多数是依靠一些可信第三方金融机构，进行电子支付。尽管这种方式能满足多数的相关交易，但仍然受到来自这种信任模式内在缺陷的威胁。由于金融机构不能避免地会对纠纷进行调解（译注：调解结果可能会撤销交易），那么完完全全的不可逆交易是不可能存在的。调解纠纷的过程又带来交易成本的提高，从而对交易规模的最小值做了限制，降低小规模交易的可能性，并且，为不可逆的服务提供不可逆的支付能力的缺失，意味着会有增加更多的成本。由于交易存在被撤销的可能，从而对信用有了越来越多的需求。商人们必须提防着他们的客户，向客户索要超出实际需求的信息。一定比例的诈骗案件被认为是不可避免的，这些成本和支付的不确定性，在人们使用实物货币时是可以避免的，但在基于电子通讯方式的支付过程中，除了通过可信第三方，没有及其他机制可行（用于避免这种不确定性成本）。

&emsp;&emsp;为了取代基于信用的支付，我们需要的是一种基于加密证明的电子支付系统，允许任意两方直接交易而不通过一个可信第三方。交易过程在计算原理上保证不可逆转，这样就可以保证卖家免于被欺骗，且用于保护买家的常规的托管机制（routine escrow mechanisms)也易于实现。在本文中，我们提出一个解决“重复支出”问题方案，该方案使用点对点(peer-to-peer)分布式时间戳服务器通过计算生成按时间排序交易证明。在该系统中，只要“诚实”的节点拥有的CPU计算能力，总体上高于任何攻击该系统的节点集团，那么这个系统就是安全的。

## 2. 交易
&emsp;&emsp;我们把一种电子货币，定义为一连串的数字签名（链）。当人们需要将他们拥有的电子货币转给其他人，需要计算前一次交易记录数据和本次交易收款人的公钥两者数据的散列码，然后使用付款人的私钥对这个散列码签名，最后将这个签名作为本次交易记录数据，追加到这个电子货币（数字签名链）的后面。交易的收款人可以通过这个签名验证当前这个电子货币的所有权。

<image>

&emsp;&emsp;这里有个问题是，交易收款人，无法验证付款人是否对当前这个电子货币做了“重复支出”。一个常规的方案是引入一个可信赖的中央权威机构，或者称为“造币厂”，对每笔交易是否“重复支出”进行检验。每笔交易结束后，这个货币都被造币厂回收，然后发行一个新币，只有造币厂直接发行的货币，才能被认为是没有重复支持的可信任的货币。

&emsp;&emsp;这个问题的解决方案，是整个货币系统的运行依赖于这些运营着“造币厂”角色的公司，所有的交易都会经过它们，就像现实中的银行。

&emsp;&emsp;我们需要一种方式，让收款人明确，（对当前这些电子货币），付款人没有签署过更早的交易。解决这个问题的重点不在于付款人是否存在“重复支出”，而在于哪比交易时间最早（译者：不管你有没重复支出，反正系统就认最早提交的那笔交易）。确认某笔交易是否存在的唯一方法就是掌握所有交易。在造币厂模型中，造币厂知悉所有的交易，然后就能确定哪一笔最早。而在没有可信第三方的场景下，所有的交易必须公诸于众，并且我们需要一个系统，让所有参与者确认这些交易的历史顺序。收款人需要检验的是，在系统中大多数的节点都确认优先收到了他（即收款人）的那笔交易。

> 译者注：
> 1. 造币厂的例子，大概是付款人将电子货币首先给造币厂，造币厂确认，然后在发行等量的由造币厂签名的电子货币给收款方，收款人可以通过造币厂的签名，确认这个电子货币是可信任的。
> 2. 重复支出的问题，首先是付款人将交易发布到所有节点，然后所有节点投票确定哪笔交易有效，即大多数节点优先收到的那笔交易有效，收款人以此位凭证，决定交易是否成功。

## 3. 时间戳服务
&emsp;&emsp;我们提的解决方案始于一个时间戳服务器。一个时间戳服务器计算并获取一个带有时间戳的数据块的Hash值，并将这个hash值广泛发布，就像在报纸或者Usernet上发布一样。这个时间戳证明了这个数据块在这个时间必然存在，显然，这是为了获取唯一的Hash值。每一个时间戳的hash值，都将其前一个时间戳在内计算，从而组成了一个数据链，链上每追加一个时间戳，就是它前面所有时间戳的一种加固。

## 4. 工作量证明（Proof-of-work）
&emsp;&emsp;在点对点（Peer-to-Peer）系统基础上实现一个分布式的时间戳服务器，我们需要使用一个称之为工作量证明的系统，该系统类似于Adam Back的Hashcash，而不仅仅是类似乎报纸或者Usernet上发布消息。这个工作量证明系统，其工作包括不断扫描以获取一些数值，这些数值的Hash值（比如SHA-256）需要满足其头部的若干位数字是0。这个平均工作量是随所需的0值的位数成指数上升，且这个数值需要能够凭一个Hash操作就能被验证。

&emsp;&emsp;对于我们的时间戳网络，工作量证明的实现方法是，在数据块中增加一个计数值(nonce)，这个值不断递增直到找到整个数据块的Hash值头部具有满足要求的0位数量。一旦CPU通过大量计算获取到了这个满足工作量证明所需的数据块，除非重新计算，这个数据块就不能被改变。后续的数据块将于前面的数据块串联在一起，改变其中一个数据块，意味着需要重头进行计算所有数据块。

&emsp;&emsp;这个工作量证明同时解决了在基于“多数服从少数”的决策机制下，如何确定谁来代表“大多数”的问题。如果所谓的“大多数”是基于一个IP地址一票的方法投票产生，那么整个系统就会被那些拥有很多IP地址分配权的角色所破坏。所以在本方案中，这个“大多数”的决定将有最长的区块链所代表，这个最长的区块链，表示其包含了最多的工作量证明（耗费最多的CPU性能）。如果这个代表“大多数”的CPU计算能力由那些诚实的节点所控制，其生成的“诚实”的区块链将越加快速地增长，并且赶超其他竞争者（区块链）。如果要篡改区块链中过去的某个区块，这个“攻击者”将需要重新计算这个区块的工作量证明，并且重新计算这个区块之后的所有区块，并且在速度上超越其他所有诚实的计算节点。我们后续将会展现在区块不断增加的情况下，一个较慢的攻击者能追赶上的概率是成指数递减的。

&emsp;&emsp;随着时间推移，硬件速度的提升以及一些节点工作侧重点的变化，为了对此进行补偿，工作量证明的计算难度，是由平均每小时计算的区块数量的移动平均值所决定。因此，如果区块的生成过快，那么难度就会增加。

## 5. 网络
&emsp;&emsp;该网络运行步骤如下：
1. 新的交易到所有网络节点。
2. 每个网络节点将所有搜集到的新交易写入一个区块。
3. 每个网络节点努力为自己的区块寻找一个相当难度的工作量证明。
4. 当节点找到一个工作量证明，就将这个区块发布给所有其他节点。
5. 只有当区块中的所有交易都有效且没有以前是没有存在过（Not Spent），那么其他节点将接受这个区块。
6. 节点接受区块的方式，是获取并使用这个接受的区块的Hash值， 来创建下一个区块并放入这个区块链中。
	
&emsp;&emsp;节点始终认为最长的那个区块链是正确的，并且致力于扩展和延长该区块链。如果两个不同的节点分别同时了两个不同版本的区块，而这两个区块都位于同一个区块链，那么不同的节点将可能分别先收到不同的区块。这种情况下，各个节点将继续工作在先收到的那个区块的基础上，同时将后收到的区块保存在另一个分支，免得以后它将变成一个最长的区块链（形成两个分支）。当后续新的工作量证明被发现，以至于其中一个分支变长后，这两个分支的联系将被打破；那个较长的区块链分支，将变成主分支，后续的工作和扩展也将切换到这个分支上来。

&emsp;&emsp;新的交易并不要求必须广播发送到网络中的所有节点上。它们只要求到达一定数目的多个节点，就会很快写入一个区块。区块广播的过程对于消息丢失也是有容错性的。如果某个节点没有收到某个区块，在收到下一个区块时，如果发现前面少了一个，就会主动向其他节点请求这个丢失的区块。

## 6. 奖励机制

&emsp;&emsp;根据约定，区块中的第一笔交易，是区块的创建者创造出并拥有一个新币的特殊的交易。这种交易为网络中所有节点增添了一种激励机制，以支撑网络运行，并在没有中央权威机构（如：央行）发行的环境中，提供一种将新币首次投放到流通环境的方式。新币数量的持续稳定增长，类似于金矿矿工耗费资源挖矿，并将黄金投入市场流通。在我们的案例中，耗费的是CPU时间和电力。

&emsp;&emsp;这个奖励也来自交易费用。如果交易结束后，一方受到的钱（交易过程的产出, output value）小于交易另一方付出的钱（Input value），那么它们的差值就是交易费用，将记录到包含这个交易的区块的奖励价值中。一旦一个预定数量的“货币”进入流通，奖励机制就可以完整的转变为依靠交易费用，因而这是完全抗通胀的。

&emsp;&emsp;这种奖励方式有助于鼓励网络节点保持诚实。如果一个贪婪的攻击者，能够组装一个比其他所有诚实节点都强大的CPU，那么他就能够以此偷回他的花费，或者以此生成新的钱币。他应该会发现，按照规则行事会更加有利可图，这些规则会为他带来比其他人多更多新的钱币，而破坏这个系统也会破坏他自有财富的有效性。




## 7. 回收磁盘空间
&emsp;&emsp;一旦某个比特币的最后一笔交易，能够覆盖足够的区块，那么此前的花费交易数据，都可以被删除以节约磁盘空间。为了满足这个要求同时不会破坏区块的Hash值，交易的Hash数据采用Merkle树的机构，且只需将Hash树根节点保存在区块中。然后过时的区块可以通过删掉Hash树的分支以减少空间占用。树内部的hash节点并不需要存储。

&emsp;&emsp;一个不包含任何交易的区块头大约需要80个字节。如果每10分钟产生一个区块，一年会有4.2MB字节。2008年的计算机系统典型配置2GB的内存，根据摩尔定律预计计算机中的内存以每年1.2GB的速度增长，那么就算区块头需要全部保存在内存中，存储方面也不会是问题。

## 8. 简单的支付验证
支付的验证不需要通过全网的节点。用户仅仅需要保存一份最长的工作量证明链中所有区块头的副本，这个副本可以向各个网络节点请求获得，在收到的所有区块链中，确定一条最长的保存，然后取得Merkle树，并将当前交易链接其所对应的区块。用户不能自行验证交易，但通过将交易连接到区块链中后，就能看到某个网络节点已经接受该交易，且随后加入的区块会进一步确认全网对该交易的接受。

&emsp;&emsp;该验证方法依赖于诚实节点对网络的控制，但一个攻击者拥有压倒性的计算能力时，这种验证方法也是脆弱的。当网络节点能够自我验证交易，那么攻击者就能够使用伪造的交易骗过这个简单的验证方法，只要攻击者持续在全网拥有压倒性的计算能力。一个防御策略是，当网络节点检测到一个无效区块时便发出警报，告知用户的软件去下载一个完整的区块和所有有争议的交易，然后进行一致性验证。对于频繁收款的商业机构，为了独立的安全性和更快速地验证，仍然愿意维护属于他们自己的网络节点。


## 9. 币值合并与拆分

&emsp;&emsp;尽管可以一个单位一个单位的处理比特币，但每阐述一个单位的币值都使用一个独立的交易，就显得有些笨重。为了允许币值拆分与合并，交易中可以包含多个输入和输出。通常可以是从之前一个大的交易中形成一个单一的输入，也可以是多个小额币值输入，合并成最多两个输出：一个用于支付，另一个用于找零。

&emsp;&emsp;需要注意的是，当一个交易依赖于其他多个交易，并且这些交易又依赖于更多的交易，这并不是一个问题。这里并不需要知道一个交易的全部历史。

## 10. 隐私

&emsp;&emsp;传统的银行模型，通过限制交易双方以及可信第三方的信息访问，实现一定级别的隐私保护。比特币设计中，将所有交易公布与众的要求，排除了使用上述传统的方法。但通过在其他一些地方阻断信息流的方式，仍旧能够维持对隐私的保护，比如保持公钥的匿名性。公众可以看到某一方将一些币值发送给另一方，但无法知道无法知道交易中的双方是谁。这与股票交易的一些信息发布设计有些类似，即单笔交易的时间和交易额是公开的，但不会告诉你交易双方是谁。

&emsp;&emsp;作为额外的防火墙，每笔交易被要求使用一对新的秘钥，以防止根据交易追溯到普通拥有者。在一些多输入的交易中，追溯仍然无法避免，因为交易中的这些输入暗示了它们属于同一个拥有者。风险在于，如果一个秘钥的拥有者被揭露，可以就此追溯到该用户的其他交易。
